<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Yihui Xie主页 |谢益辉</title><link/>https://yihui.org/<description> Yihui Xie首页近期内容|谢益辉</description><generator>雨果——gohugo.io</generator><language>英文</language><lastbuilddate>2017 年 1 月 31 日星期二 00:00:00 +0000 </lastbuilddate><atom:link href="https://yihui.org/" rel="self" type="application/rss+xml"></atom:link><item><title> DT包的状态</title><link/>https://yihui.org/en/2023/05/dt-status/<pubDate> Mon, 15 May 2023 00:00:00 +0000</pubDate><author>谢益辉</author><guid>https://yihui.org/en/2023/05/dt-status/ </guid><description><![CDATA[
        
        <p>我在 RStudio（现在更名为 Posit）的第一份工作是将 JS 库<a href="https://datatables.net">DataTables</a>集成到<a href="https://shiny.posit.co">Shiny</a>中。那是2013年，差不多十年前。老实说，我从来都对表格不感兴趣，从事表格工作只是我职业生涯的一个偶然开始。由于 DataTables 是一个相当复杂的库，而且它的许多功能在 Shiny 之外也很有用，我们在 2014 年决定制作一个基于<a href="https://www.htmlwidgets.org">HTML Widgets</a>框架的独立包。 <strong>DT</strong>包就是这样诞生的。</p><p>不幸的是，随着这些年来我维护的 R 包越来越多，我发现主动维护<strong>DT</strong>越来越困难。 2020 年，有人给我发了这张 XKCD 卡通片，说这让他想起了我：</p><p> <a href="https://xkcd.com/2347/"><img src="https://imgs.xkcd.com/comics/dependency.png" alt="依赖(XKCD)"></a></p><p>他感谢我并说：“我认为你住在爱荷华州，但仍然如此”。有趣的是，我确实住在内布拉斯加州！我曾开发过一些基础设施包，如<strong>knitr</strong>和<strong>rmarkdown</strong> ，但我不能像卡通中描述的那样获得如此多的荣誉。也就是说，我的工作方式类似于动画片中的支柱——我经常独自工作。我确实<a href="https://yihui.org/en/2019/07/romain-lesur/">与其他人合作</a>，并在 Github 上合并了许多 pull request，但大多数时候，我仍然独自工作。</p><p>对于<strong>DT</strong>包，我最后一次对其进行实质性工作是在<a href="/en/2018/01/back-to-dt/">五年前</a>。我很幸运有<a href="https://github.com/rstudio/DT/graphs/contributors">一些志愿者</a>不时帮助我维护这个包（特别是<a href="https://github.com/shrektan">@shrektan</a>和<a href="https://github.com/stla">@stla</a> ）。我已经在 Posit 内部询问过几次是否有可能出现新的维护者，但似乎没有人感兴趣，所以我必须继续。</p><p>我写这篇文章是为了设定期望：除非有人可以承诺维护这个包，否则它将进入仅维护模式，这意味着我不会再向它添加大量新功能。但是，如果有人想要一个不太复杂的新功能并通过拉取请求实现它，我可能可以审查并合并它。同样的事情也适用于错误修复（除非它是一个非常糟糕的错误，在这种情况下我仍然会尝试自己修复它）。</p><p>有<a href="https://bookdown.org/yihui/rmarkdown-cookbook/table-other.html">很多用于生成表的 R 包</a>，但我觉得<strong>DT</strong>提供了两个在其他包中还不直接的独特功能：<a href="https://rstudio.github.io/DT/server.html">服务器端处理</a>和<a href="https://rstudio.github.io/DT/#table-editing">表编辑</a>。 <a href="https://rstudio.github.io/DT/extensions.html">DataTables 扩展</a>的某些功能在其他包中也可能不可用。</p><p>请放心， <strong>DT</strong>不会很快死去。它将在未来几年留在 CRAN 上。只是在热情的新维护者从我的肩上接过它之前，您可能不会期望从这个包中获得任何令人兴奋的新功能。如果您认为没有消息就是好消息，那么这对您来说就是个好消息。</p><p> PS 在我收到XKCD卡通几个月后，没看过卡通的儿子碰巧在家里用巨型积木做了这个玩具，我觉得很有趣： </p><p><img src="https://user-images.githubusercontent.com/163582/238486514-eaf186bd-7bf1-41c1-b545-2ebc34be589d.jpg" alt="依赖（Mega blocks版本）"></p><script>location.href='https://yihui.org/en/2023/05/dt-status/';</script> ]]>;</description></item><item><title>分享您的善意</title><link/>https://yihui.org/en/2023/04/share-your-goodwill/<pubDate> Fri, 28 Apr 2023 00:00:00 +0000</pubDate><author>谢益辉</author><guid>https://yihui.org/en/2023/04/share-your-goodwill/ </guid><description><![CDATA[
        
        <p>最近在家经常听到儿子唱一首歌，听着很感人。他口中残缺的歌词包括“记住，还有人不如你幸运”之类的句子。这正是自从他四岁抱怨桌上的食物时我一直在告诉他的话（只要你有东西吃就心存感激，因为世界上还有人在忍受饥饿）。</p><p>我问他这是什么歌，他告诉我是“善意”。我从来没有听说过它，也没有通过谷歌找到它。然后他告诉我这是他老师写的，这就解释了为什么我找不到它。所以我问他的老师，他告诉我这是特蕾莎·詹宁斯写的，题为“<a href="https://www.musick8.com/html/current_tune.php?numbering=52&amp;songorder=4">分享你的善意</a>”。在我了解到这一点后，我能够在几秒钟内找到它。</p><blockquote><p>当你晚上有地方睡觉时，<br>有饭吃的时候，<br>当你有一件外套来保暖时，<br>和你脚上的鞋子，<br>记得有人<br>没有你那么幸运。<br>请记住，他们可能需要您的帮助。<br>你知道你能做什么。</p><p>你可以分享你的善意。<br>哦，分享你的善意。<br>哦，请记住人类<br>并分享您的善意。<br>你可以分享你的善意。<br>哦，分享你的善意。<br>哦，请记住人类<br>并分享您的善意。</p><p>当你有一所学校教你东西时，<br>当你有机会学习时，<br>当你有一份工作，一份生计，<br>一种让你赚钱的方式，<br>记得有人<br>没有你那么幸运。<br>请记住，他们可能需要您的帮助。<br>你知道你能做什么。</p><p>分享您的善意！<br>分享您的善意！<br>哦，请记住人类和<br>分享您的善意！<br>你可以分享你的善意！<br>分享您的善意！<br>哦，记住人类并分享，<br>哦，分享你的善意！<br>你的善意！</p></blockquote><p>我非常喜欢这首歌。想必大多数大人小时候都唱过这样一首歌，可是长大后，我们还是处处需要《行为准则》这样的东西…… </p><!--#
It also reminds me of this line in "The Great Gatsby":

“Whenever you feel like criticizing any one [...] just remember that all the people in this world haven't had the advantages that you've had.”
--><script>location.href='https://yihui.org/en/2023/04/share-your-goodwill/';</script> ]]>;</description></item><item><title>你必须 get() 对象吗？</title><link/> https://yihui.org/en/2023/04/get-objects/<pubDate> Wed, 12 Apr 2023 00:00:00 +0000</pubDate><author>谢益辉</author><guid>https://yihui.org/en/2023/04/get-objects/ </guid><description><![CDATA[
        
        <p>上个月我在 Stack Overflow 上看到<a href="https://stackoverflow.com/q/75819997/559676">一个有趣的问题</a>，其中 OP 想将一系列数据框打印为表格，并尝试了双循环，但没有用：</p><pre> <code class="language-r">for (i in c(&quot;CP&quot;, &quot;BK&quot;, &quot;IT&quot;, &quot;WP&quot;)) { for (j in c(&quot;DD&quot;, &quot;SI&quot;)) { data &lt;- get(paste0(i, &quot;_&quot;, j, &quot;_comb1&quot;)) print(data) } }</code></pre><p>这不起作用的原因有两个：</p><ol><li> <code>print()</code>不创建表。您必须明确地（例如，通过<code>knitr::kable()</code> ）或不明确地（例如，通过 R Markdown 中的<a href="https://bookdown.org/yihui/rmarkdown/html-document.html#data-frame-printing"><code>df_print</code>选项</a>）创建一个表。</li><li>表必须打印在<a href="/en/2017/06/top-level-r-expressions/">顶级表达式</a>中。默认情况下，它们不会在循环内生成。</li></ol><p>我在那里发布了一个答案，以根据块选项<code>code</code>创建顶级表达式来打印数据帧。但是，我认为一定有更深层次的问题，我可能对错误的问题提供了正确的答案。也就是说，如果您必须通过名称<code>get()</code>一系列对象，并且这些名称<em>共享一个模式</em>（例如，原始问题中的<code>*_*_comb1</code> ），也许这些对象本来就不应该存在！</p><p>如果它们存在，则意味着作者必须以如下方式创建它们：</p><pre> <code class="language-r">CP_DD_comb1 &lt;- ... BK_DD_comb1 &lt;- ... IT_DD_comb1 &lt;- ... WP_DD_comb1 &lt;- ... CP_SI_comb1 &lt;- ... BK_SI_comb1 &lt;- ... IT_SI_comb1 &lt;- ... WP_SI_comb1 &lt;- ...</code></pre><p> <code>...</code>中的代码还必须有一个模式，如<code>subset(data, X1 == &quot;CP&quot; &amp; X2 == &quot;DD&quot;)</code> ，这很可能违反 DRY 原则（不要重复自己）。</p><p>当您发现自己创建了一系列名称中带有模式的对象时，我会说您可能做错了。与其创建这些全局对象，不如只创建一个对象——一个包含这些对象的列表。例如，如果您想按<code>cyl</code>和<code>am</code>变量对<code>mtcars</code>数据进行分区，则不应创建像<code>cyl_8_am_0</code>这样的对象。相反，您创建一个列表：</p><pre> <code class="language-r">mtcars_list &lt;- split(mtcars, ~ cyl + am)</code></pre><p>然后，如果您想为<code>cyl</code>和<code>am</code>的每个组合创建一个表，您只需编写一行代码：</p><pre> <code class="language-r">knitr::kable(mtcars_list)</code></pre><p>这比首先创建多个全局对象（这会污染全局环境），然后通过<code>get()</code>检索它们（如果您对它的<code>envir</code> 、 <code>mode</code>和<code>inherits</code>参数不够小心，这可能会咬你）要优雅和简单得多，最后一张一张打印出来。</p><p>我认为您应该很少需要在日常代码中使用<code>get()</code> ，就像<a href="/en/2023/02/eval-parse/">您应该很少需要<code>eval()</code></a>一样。如果您不得不求助于<code>get()</code> ，则可能存在更深层次的问题，您可能需要停下来重新思考。 </p><script>location.href='https://yihui.org/en/2023/04/get-objects/';</script> ]]>;</description></item><item><title>将行内脚注转换为 Markdown 中的常规脚注</title><link/>https://yihui.org/en/2023/02/markdown-footnotes/<pubDate> Thu, 23 Feb 2023 00:00:00 +0000</pubDate><author>谢益辉</author><guid>https://yihui.org/en/2023/02/markdown-footnotes/ </guid><description><![CDATA[
        
        <p>在我的个人网站使用<a href="https://github.com/gohugoio/hugo/releases/tag/v0.25.1">Hugo 0.25.1</a>将近六年之后，我终于决定升级它。我稍后会解释原因。我遇到的一个问题是，我必须将 Markdown 中的<a href="https://pandoc.org/MANUAL.html#extension-inline_notes">行内脚注</a>转换为<a href="https://pandoc.org/MANUAL.html#footnotes">常规脚注</a>（因为 Hugo 0.25.1 支持前者，但 Hugo 从后来的某个版本开始不再支持它）。也就是说，我需要转换</p><pre><code class="language-markdown">text^[this is a footnote]</code></pre><p>到</p><pre><code class="language-markdown">text[^1] [^1]: this is a footnote</code></pre><p>我可以使用 Pandoc 来做到这一点，但由于我有几千篇文章，我不想让它们都经过 Pandoc 转换，以避免意外损坏。相反，我只是写了一个小的 R 脚本来帮助：</p><pre> <code class="language-r">files = list.files(&#39;.&#39;, &#39;[.]R?md$&#39;, recursive = TRUE, full.names = TRUE) for (f in files) { x = xfun::read_utf8(f) r = &#39;\\^\\[([^]]+)\\]&#39; # eyes bleeding... if (length(grep(r, x)) == 0) next fn = NULL m = gregexpr(r, x) regmatches(x, m) = lapply(regmatches(x, m), function(z) { if ((n &lt;- length(z)) == 0) return(z) z2 = sprintf(&#39;[^%d]&#39;, length(fn) + seq_len(n)) fn &lt;&lt;- c(fn, gsub(r, &#39;\\1&#39;, z)) z2 }) fn = sprintf(&#39;[^%d]: %s&#39;, seq_along(fn), fn) x = c(x, rbind(&#39;&#39;, fn)) xfun::write_utf8(x, f) }</code></pre><p>基本上，它读取一个<code>.md</code> （或<code>.Rmd</code> ）文件，检测文本中<code>^[text]</code>形式的所有脚注，用<code>[^n]</code>替换它们（其中<code>n</code>是脚注编号），附加新脚注<code>[^n]: text</code>到文本，并写出到原始文件。由于我的文件处于版本控制之下，我可以手动检查<a href="https://github.com/yihui/yihui.org/commit/f518a9a">GIT 更改</a>以确认脚本是否符合我的预期。</p><p>它确实帮助了我很多，而且我只有一个特例——包含<code>]</code>的脚注，例如<code>^[this is a [footnote](url)]</code> 。幸运的是，我没有太多带有这种脚注的帖子，所以我手动更正了它们。</p><p>为什么要升级 Hugo？我真的没有充分的理由。一个原因是由于 Hugo 的旧版本，我已经厌倦了<a href="/en/2017/08/hugo-post-summary/">不得不使用<code>.Scratch</code></a> 。另一个原因是作为<strong>blogdown</strong>包的维护者，我想关注 Hugo 的更新版本。对于普通用户，通常我不建议升级 Hugo，只要某个版本适合你就行。 </p><script>location.href='https://yihui.org/en/2023/02/markdown-footnotes/';</script> ]]>;</description></item><item><title>在网页上设计键盘键和快捷方式</title><link/>https://yihui.org/en/2023/02/key-buttons/<pubDate> Wed, 22 Feb 2023 00:00:00 +0000</pubDate><author>谢益辉</author><guid>https://yihui.org/en/2023/02/key-buttons/ </guid><description><![CDATA[
        
        <p>在网页上编写键盘快捷键时，我们经常使用 HTML 中的<code>&lt;code>;</code>标签，或者等价地，Markdown 中的一对反引号。因此，这些键被设置为代码样式。我一直在考虑将它们设置为<code>&lt;kbd>;</code>样式，这在语义上更合适，并且<code>&lt;kbd>;</code>可以具有与<code>&lt;code>;</code>不同的视觉样式。</p><p>昨天我写了一小段<a href="https://github.com/yihui/misc.js/blob/main/js/key-buttons.js">JavaScript 代码</a>将<code>&lt;code>;Key&lt;/code>;</code>转换为 HTML 页面上的<code>&lt;kbd>;Key&lt;/kbd>;</code> ，还写了几行<a href="https://github.com/yihui/misc.js/blob/main/css/key-buttons.css">CSS 代码</a>将<code>&lt;kbd>;</code>设置为按钮。您可以导入 JS 和 CSS：</p><pre> <code class="language-html">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/@xiee/utils/js/key-buttons.min.js&quot; defer>;&lt;/script>; &lt;link href=&quot;https://cdn.jsdelivr.net/npm/@xiee/utils/css/key-buttons.min.css&quot; rel=&quot;stylesheet&quot;>;&lt;/link>;</code></pre><h2 id="demos">演示</h2><p>下面是一些例子：</p><p> <code>Esc</code> <code>Tab</code> <code>Enter</code> <code>Space</code> <code>Delete</code> <code>Home</code> <code>End</code> <code>PrtScr</code> <code>PrintScreen</code> <code>PageUp</code> <code>PageDown</code> <code>Up</code> <code>Down</code> <code>Left</code> <code>Right</code></p><p> <code>Ctrl</code> <code>Control</code> <code>Shift</code> <code>Alt</code> <code>Cmd</code> <code>Command</code> <code>fn</code></p><p> <code>Ctrl / Cmd + C</code></p><p> <code>Ctrl / Cmd + Alt + I</code></p><p> <code>Shift + Enter</code></p><p> <code>Cmd + Shift + 9</code></p><p> <code>fn + F</code></p><p> <code>Alt + Click</code></p><h2 id="how-does-it-work">它是如何工作的？</h2><p>在幕后，JS 代码首先查找不是<code>&lt;pre>;</code>子级的<code>&lt;code>;</code>标签。对于每个标签，它使用试探法来确定它看起来像一个键还是键盘快捷键。例如， <code>&lt;code>;Esc&lt;/code>;</code>和<code>&lt;code>;PageDown&lt;/code>;</code>等单个键被识别并转换为<code>&lt;kbd>;</code>标签；对于键盘快捷键，它们必须以<code>Ctrl / Cmd / Shift / Alt / fn</code>键之一开头，然后是<kbd>/</kbd>或<kbd>+</kbd> 。键必须由<kbd>/</kbd>或<kbd>+</kbd>分隔，分隔符的每一侧各有一个空格，例如， <code>Ctrl + Key</code>将被识别，但<code>F12 + C</code> 、 <code>Ctrl - V</code>和<code>Ctrl+Key</code>将不会被识别。如果检测到键盘快捷键，则将每个键放入<code>&lt;kbd>;</code>标记中，例如， <code>&lt;code>;Ctrl + Key&lt;/code>;</code>转换为<code>&lt;kbd>;Ctrl&lt;/kbd>; + &lt;kbd>;Key&lt;/kbd>;</code> .</p><p>箭头键和 Enter 键是特殊情况：您将键名写在<code>&lt;code>;</code>中，例如，</p><pre> <code class="language-html">&lt;code>;Enter&lt;/code>; &lt;code>;Up&lt;/code>; &lt;!-- or in Markdown -->; `Enter` `Up`</code></pre><p>它们将被转换为箭头（带有工具提示，以防箭头混淆）：</p><pre> <code class="language-html">&lt;kbd title=&quot;Enter&quot;>;↵&lt;/kbd>; &lt;kbd title=&quot;Up Arrow&quot;>;↑&lt;/kbd>;</code></pre><p>目前，并非所有键都受支持。我写的脚本主要是为了自己使用，并且只包含了我经常使用的键。如果您需要支持其他密钥，请随时在下面的评论中告诉我或<a href="https://github.com/yihui/misc.js">向 Github 提交问题</a>。但是，还请注意，当不支持某个键时，您始终可以使用原始 HTML 标记<code>&lt;kbd>;</code> ，例如， <code>&lt;kbd>;F&lt;/kbd>;</code>将呈现为<kbd>F。</kbd> Markdown 通常支持原始 HTML，因此当一对反引号（例如， <code>`F`</code> ）不起作用时， <code>&lt;kbd>;</code>是一种解决方法。以下是一些写在<code>&lt;kbd>;</code>标签中的键：</p><p> <kbd>a</kbd> <kbd>b</kbd> <kbd>c</kbd> <kbd>d</kbd> <kbd>e</kbd> <kbd>f</kbd> <kbd>g</kbd> <kbd>h</kbd> <kbd>i</kbd> <kbd>j</kbd> <kbd>k</kbd> <kbd>l</kbd> <kbd>m</kbd> <kbd>n</kbd> <kbd>o</kbd> <kbd>p</kbd> <kbd>q</kbd> <kbd>r</kbd> <kbd>s</kbd> <kbd>t</kbd> <kbd>u</kbd> <kbd>v</kbd> <kbd>w</kbd> <kbd>x</kbd> <kbd>y</kbd> <kbd>z</kbd> <kbd>A</kbd> <kbd>B</kbd> <kbd>C</kbd> <kbd>D</kbd> <kbd>E</kbd> <kbd>F</kbd> <kbd>G</kbd> <kbd>H</kbd> <kbd>I</kbd> <kbd>J</kbd> <kbd>K</kbd> <kbd>L</kbd> <kbd>M</kbd> <kbd>N</kbd> <kbd>O</kbd> <kbd>P</kbd> <kbd>Q</kbd> <kbd>R</kbd> <kbd>S</kbd> <kbd>T</kbd> <kbd>U</kbd> <kbd>V</kbd> <kbd>W</kbd> <kbd>X</kbd><kbd>是</kbd><kbd>0</kbd> <kbd>1</kbd> <kbd>2</kbd> <kbd>3</kbd> <kbd>4</kbd> <kbd>5</kbd> <kbd>6</kbd> <kbd>7</kbd> <kbd>8</kbd> <kbd>9</kbd> <kbd>_</kbd></p><h2 id="the-css-style"> CSS 样式</h2><p><code>&lt;kbd>;</code>标签的样式为带有圆角和框阴影的按钮（灵感来自<a href="https://shhdharmen.github.io/keyboard-css/">keyboard-css</a>和<a href="https://chrispennington.blog/blog/add-styling-to-keyboard-keys-css/">这篇文章</a>）。当您将鼠标移到它上面时，它会“下沉”一点。当然，您可以添加更多 CSS 规则或覆盖我的规则来更改样式。</p><p>我认为从<code>&lt;code>;</code>到<code>&lt;kbd>;</code>的转变将使键盘快捷键脱颖而出，以便读者可以更清楚地看到它们。 </p><script>location.href='https://yihui.org/en/2023/02/key-buttons/';</script> ]]>;</description></item><item><title>你应该很少需要 eval(parse())</title><link/> https://yihui.org/en/2023/02/eval-parse/<pubDate> Tue, 07 Feb 2023 00:00:00 +0000</pubDate><author>谢益辉</author><guid>https://yihui.org/en/2023/02/eval-parse/ </guid><description><![CDATA[
        
        <p>许多编程语言都有将字符串作为代码或表达式求值的函数，例如 R 中的<code>eval()</code> 。一旦您学会了它，就很容易滥用它。您不再自然而直接地编写代码，而是开始考虑<em>编写构造要评估的代码的代码</em>。例如，而不是写<code>1 + 1</code> ，你可以写这样一个怪物：</p><pre> <code class="language-r">eval(parse(text = paste(c(&#39;1&#39;, &#39;1&#39;), collapse = &#39;+&#39;)))</code></pre><p>这显然只是一个愚蠢的例子，但我在过去看到人们多次滥用 R 中的<code>eval()</code> ，通常是由于对函数缺乏理解。一个例子是<a href="https://stackoverflow.com/q/74564027/559676">最近的 Stack Overflow 问题</a>。 OP 想通过<code>knitr::include_graphics()</code>包含一系列图形，但没有意识到这个函数只能采用图形路径的向量，然后 OP 编写代码来构造由一系列<code>knitr::include_graphics()</code>调用。</p><p>这种思维方式不仅常常导致代码笨拙，而且当您作为开发人员允许用户输入任何要评估的字符串时，也会带来安全风险。</p><p>当然， <code>eval(parse())</code>有很大的价值，我并不是说它应该被禁止。例如，整个<strong>knitr</strong>包都建立在它之上（用于将代码块评估为代码字符串）。但是，我觉得这几乎肯定是您日常编程工作的错误方式。应该有更好的方法。 </p><script>location.href='https://yihui.org/en/2023/02/eval-parse/';</script> ]]>;</description></item><item><title>没有 Shiny 的 Shiny App：R Markdown 中的 JavaScript 练习</title><link/>https://yihui.org/en/2023/02/js-shiny/<pubDate> Tue, 07 Feb 2023 00:00:00 +0000</pubDate><author>谢益辉</author><guid>https://yihui.org/en/2023/02/js-shiny/ </guid><description><![CDATA[
        
        <p>请忽略这篇文章的标题。太夸张了。在这篇文章中，我想展示一个具有 Shiny 应用程序感觉的示例，但它在运行时并没有真正使用 Shiny 或 R 作为后端。这个例子来自<a href="https://d.cosx.org/d/423312/12">我在论坛上的一个回答</a>，主要针对有兴趣学习一点 JavaScript 的初学者，虽然我不是 JavaScript 专家。以下是完整的 R Markdown 文档：</p><pre> <code class="language-markdown">--- title: &quot;Change the number of bins of a histogram&quot; --- ```{r, setup, echo=FALSE} n_breaks = c(5, 10, 15, 20) shiny::selectInput( &#39;n_breaks&#39;, label = &#39;Number of bins&#39;, choices = n_breaks, selected = 5) ``` Draw all histograms and put them in a container with the class `hist-all`. ```{r, class.chunk=&#39;hist-all&#39;} x = faithful$eruptions for (i in n_breaks) { hist(x, breaks = seq(min(x), max(x), length.out = i + 1), main = paste(&#39;n = &#39;, i)) } ``` But we hide all of those images initially with CSS. ```{css} /* hide all images */ .hist-all img { display: none; } /* but show the image with the class &#39;show&#39; */ .hist-all .show { display: block; } ``` When the choice in the select input is changed, show the histogram with the selected number of bins. ```{js} (d =>; { const s = d.getElementById(&#39;n_breaks&#39;), // the select input imgs = d.querySelectorAll(&#39;.hist-all img&#39;); // all histograms // add the class &#39;show&#39; to the i-th image, where i is the // selected number in the select input function showImg() { const i = s.selectedIndex; imgs.forEach((el, k) =>; { // k is the index of the image; i is the index of the choice // in the select input; add the class &#39;show&#39; if the two // indices are equal el.classList.toggle(&#39;show&#39;, k == i); }); } // show the initial image showImg(); // show a different image when select input is changed s.onchange = showImg; })(document); ```</code></pre><p>您可以将文档编织成 HTML 以使用选择输入进行播放，或者<a href="https://rpubs.com/yihui/js-shiny">访问我的演示</a>。我个人喜欢这个示例，因为它结合了我最喜欢的技术：R、CSS 和 JavaScript。 R 用于绘图，CSS 用于外观，JavaScript 用于交互。我已尝试对代码进行详细注释，希望它不会太难理解。 JavaScript 的关键部分是<code>el.classList.toggle()</code> 。</p><p>当您想在没有 R 或 Shiny 运行的静态 HTML 页面上一个接一个地呈现多个图时，此示例可能很有用。但猜猜怎么了？有朝一日，您也许可以在没有 R 或 Shiny 的情况下在 Web 浏览器中运行真正的 Shiny 应用程序<a href="https://github.com/georgestagg/webR">——WASM 获胜</a>！ </p><script>location.href='https://yihui.org/en/2023/02/js-shiny/';</script> ]]>;</description></item><item><title>在 R Markdown 中使用 JavaScript 操作 SVG 图</title><link/>https://yihui.org/en/2023/02/manipulate-svg/<pubDate> Tue, 07 Feb 2023 00:00:00 +0000</pubDate><author>谢益辉</author><guid>https://yihui.org/en/2023/02/manipulate-svg/ </guid><description><![CDATA[
        
        <p>SVG 图形格式本质上是 XML。您可以使用<strong>knitr</strong>块选项<code>dev = &#39;svg&#39;</code> （或<code>&#39;svglite&#39;</code>或其他 SVG 设备）轻松生成 SVG 图。但是，它们使用<code>&lt;img>;</code>标记嵌入到 HTML 输出文档中，这意味着即使它们是 XML，您也无法对其进行操作。多年来我一直希望嵌入原始 XML，以便可以操作 SVG 图。我没有足够强烈的动力，尽管我觉得这可能会有用。</p><p>去年 7 月，JooYoung Seo 向<strong>knitr</strong>提交了<a href="https://github.com/yihui/knitr/issues/2152">功能请求</a>，我终于有了动力！对于视障人士或盲人，他们可以使用 JavaScript 与 SVG 绘图进行交互，以便他们可以听到绘图中的信息。我在这方面真的没有太多经验，但我在这篇文章中分享了一个简单的例子来揭示潜力。</p><p>关键是设置选项<code>options(knitr.svg.object = TRUE)</code>让<strong>knitr</strong>将 SVG 图作为原始 XML 嵌入到 HTML 输出文档中。一旦 SVG 图是 HTML 节点，您就可以选择该节点及其子节点。然后您可以使用任何 JavaScript 技术来操作它们。</p><p>下面是一个 R Markdown 示例，它向您展示了如何在条形图中升高条形并在将鼠标移到条形图上时同时发出蜂鸣声。</p><pre> <code class="language-markdown">--- title: &quot;Manipulate SVG plots&quot; --- ```{r setup, include=FALSE} options(knitr.svg.object = TRUE) ``` Draw a barplot with an ID `my-plot` and the SVG format. ```{r dev=&#39;svg&#39;, out.extra=&#39;id=&quot;my-plot&quot;&#39;} barplot(1:10) ``` Add `mouseover` events on all bars. ```{js} document.querySelectorAll(&#39;#my-plot #surface4 path&#39;).forEach(el =>; { // beep for 500 milliseconds // code adapted from https://stackoverflow.com/a/29641185/559676 function beep() { const ctx = new AudioContext(); var osc = ctx.createOscillator(); osc.type = &#39;sine&#39;; osc.frequency.value = 800; osc.connect(ctx.destination); osc.start(); setTimeout(() =>; { osc.stop(); }, 100); } el.addEventListener(&#39;mouseover&#39;, e =>; { this.event.target.style.transform = &#39;rotateX(15deg)&#39;; beep(); }); el.addEventListener(&#39;mouseout&#39;, e =>; { this.event.target.style.transform = &#39;&#39;; }); }); ```</code></pre><p>您可以将此文档编织成 HTML 并将鼠标移到每个栏上以查看效果，或者只是<a href="https://rpubs.com/yihui/manipulate-svg">访问我发布的演示</a>。要听到声音，您可能需要至少点击一次页面（因为浏览器可能不允许在没有用户交互的情况下播放声音）。</p><p> JavaScript 代码<code>document.querySelectorAll(&#39;#my-plot #surface4 path&#39;)</code>选择图中的所有条形。对于每个条， <code>mouseover</code>事件将触发哔声和 CSS 转换以将条升高一点（ <code>rotateX(15deg)</code> ）。对于<code>mouseout</code>事件，转换被撤销。</p><p>这种将 SVG 作为 XML 嵌入到 HTML 输出文档中的功能首先在<strong>knitr</strong> 1.40（2022 年 8 月 24 日发布）中引入。我希望你会发现它有用和有趣。特别感谢 JooYoung 的鼓励！ </p><script>location.href='https://yihui.org/en/2023/02/manipulate-svg/';</script> ]]>;</description></item><item><title>弃用 xfun::isFALSE()</title><link/> https://yihui.org/en/2023/02/xfun-isfalse/<pubDate> Mon, 06 Feb 2023 00:00:00 +0000</pubDate><author>谢益辉</author><guid>https://yihui.org/en/2023/02/xfun-isfalse/ </guid><description><![CDATA[
        
        <p>Base R 多年来一直具有<code>isTRUE()</code>功能，几年来我一直希望也有一个<code>isFALSE()</code> 。在将它作为函数<code>isFALSE()</code>添加到<strong>xfun</strong>包的第一个版本之前，我曾多次使用<code>identical(x, FALSE)</code> 。 <strong>xfun</strong>包于 2018-01-22 首次发布到 CRAN。</p><p>三个月后（2018-04-23），R 3.5.0 发布，其中在基础包中包含一个名为<code>isFALSE()</code>的函数。显然，另一个人的想法和我一样（后来证明是 Martin Mächler）。</p><p>啊…</p><p>去年 Martin 发送了<a href="https://github.com/yihui/xfun/pull/66">一个 pull request</a>来从<strong>xfun</strong>中删除<code>isFALSE()</code> ，这是我长期以来一直希望做的，但我不能只删除它，因为它被用在我维护的相当多的包中。最近我删除了它们中的用法并检查了<strong>xfun</strong>的所有反向依赖项。如果我弃用<code>xfun::isFALSE()</code> ，似乎没有其他包会受到影响，这是个好消息。不过，我不确定它是否被任何人用于非包代码。</p><p>不管怎样，我今天宣布弃用<code>xfun::isFALSE()</code> （我希望这是你第一次也是最后一次听说这个函数）。现在，如果您仍然在包中使用它，它会在<code>R CMD check</code>期间抛出错误。将来，如果<code>base::isFALSE()</code>存在，它只会抛出一个错误。最后，我只是将它从<strong>xfun</strong>中删除，您应该在 base R 中使用<code>isFALSE()</code>代替。我希望它不会对您的代码产生太大影响。如果确实如此，我深表歉意。</p><p>如果我再等三个月，我就不会遇到这个麻烦了。时机有时很有趣。 </p><script>location.href='https://yihui.org/en/2023/02/xfun-isfalse/';</script> ]]>;</description></item><item><title>我的关于使用最小应用程序解释 R Markdown 的网络研讨会</title><link/>https://yihui.org/en/2023/01/minimal-r-markdown/<pubDate> Tue, 10 Jan 2023 00:00:00 +0000</pubDate><author>谢益辉</author><guid>https://yihui.org/en/2023/01/minimal-r-markdown/ </guid><description><![CDATA[
        
        <p>ASA 统计计算部门今天邀请我参加网络研讨会（美国中部标准时间下午 1:30-2:30）。您可以在<a href="https://uconn-cmr.webex.com/weblink/register/r1402166f1b250cd6c20315a6ec1aed62">注册页面</a>上看到摘要。在某种程度上，这将是一个奇怪的谈话，因为我正在“倒退”谈论第一代 R Markdown。我不希望这次演讲能使大量听众受益，但我认为我最终至少得到了一个有趣的应用。谈话将是相当技术性的（即乏味）。如果你无论如何都想来，请尽量晚到半小时。</p><p>演讲已被录制并可<a href="https://youtu.be/fiy32LjgGUE">在 YouTube 上观看</a>。幻灯片可<a href="https://slides.yihui.org/2023-minimal-r-markdown.html">在此处获得</a>。 </p><script>location.href='https://yihui.org/en/2023/01/minimal-r-markdown/';</script> ]]>;</description></item></channel></rss>